
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/pysap-mri/GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_pysap-mri_GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_pysap-mri_GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.py:


GPU non-cartesian reconstruction with SENSE
===========================================

Author: Chaithya G R

In this tutorial we will reconstruct an MR Image directly with density
compensation and SENSE from gpuNUFFT

Import neuroimaging data
------------------------

We use the toy datasets available in pysap, more specifically a 3D orange data
and the radial acquisition scheme (non-cartesian).

.. GENERATED FROM PYTHON SOURCE LINES 18-19

Package import

.. GENERATED FROM PYTHON SOURCE LINES 19-33

.. code-block:: default

    from mri.operators import NonCartesianFFT, WaveletN
    from mri.operators.utils import normalize_frequency_locations
    from mri.operators.fourier.utils import estimate_density_compensation
    from mri.reconstructors import SelfCalibrationReconstructor
    from mri.reconstructors.utils.extract_sensitivity_maps import get_Smaps
    from pysap.data import get_sample_data

    # Third party import
    from modopt.math.metrics import ssim
    from modopt.opt.linear import Identity
    from modopt.opt.proximity import SparseThreshold
    import numpy as np
    import matplotlib.pyplot as plt


.. GENERATED FROM PYTHON SOURCE LINES 34-35

Loading input data

.. GENERATED FROM PYTHON SOURCE LINES 35-43

.. code-block:: default

    image = get_sample_data('3d-pmri').data.astype(np.complex64)
    cartesian = np.linalg.norm(image, axis=0)

    # Obtain MRI non-cartesian mask and estimate the density compensation
    radial_mask = get_sample_data("mri-radial-3d-samples")
    kspace_loc = normalize_frequency_locations(radial_mask.data)
    density_comp = estimate_density_compensation(kspace_loc, cartesian.shape, 'pipe', backend='gpunufft')


.. GENERATED FROM PYTHON SOURCE LINES 44-45

View Input

.. GENERATED FROM PYTHON SOURCE LINES 45-53

.. code-block:: default

    plt.subplot(1, 2, 1)
    plt.imshow(cartesian[..., 80], cmap='gray')
    plt.title("MRI Data")
    ax = plt.subplot(1, 2, 2, projection='3d')
    ax.scatter(*kspace_loc[::500].T, s=0.1, alpha=0.5)
    plt.title("K-space Sampling Mask")
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 54-60

Generate the kspace
-------------------

From the 3D orange slice and 3D radial acquisition mask, we retrospectively
undersample the k-space
We then reconstruct using adjoint with and without density compensation

.. GENERATED FROM PYTHON SOURCE LINES 60-69

.. code-block:: default


    # Get the locations of the kspace samples and the associated observations
    fourier_op = NonCartesianFFT(
        samples=kspace_loc,
        shape=cartesian.shape,
        n_coils=image.shape[0],
        implementation='gpuNUFFT',
    )
    kspace_obs = fourier_op.op(image)

.. GENERATED FROM PYTHON SOURCE LINES 70-71

Obtrain the Sensitivity Maps

.. GENERATED FROM PYTHON SOURCE LINES 71-82

.. code-block:: default

    Smaps, SOS = get_Smaps(
        k_space=kspace_obs,
        img_shape=fourier_op.shape,
        samples=kspace_loc,
        thresh=(0.05, 0.05, 0.05),  # The cutoff threshold in each kspace
                                    # direction between 0 and kspace_max (0.5)
        min_samples=kspace_loc.min(axis=0),
        max_samples=kspace_loc.max(axis=0),
        density_comp=density_comp,
        mode='NFFT',
    )

.. GENERATED FROM PYTHON SOURCE LINES 83-84

View Input

.. GENERATED FROM PYTHON SOURCE LINES 84-90

.. code-block:: default

    for i in range(9):
        plt.subplot(3, 3, i+1)
        plt.imshow(np.abs(Smaps[i][..., 80]), cmap='gray')
    plt.suptitle("Sensitivty Maps")
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 91-92

Density Compensation adjoint:

.. GENERATED FROM PYTHON SOURCE LINES 92-108

.. code-block:: default

    fourier_op_sense_dc = NonCartesianFFT(
        samples=kspace_loc,
        shape=cartesian.shape,
        implementation='gpuNUFFT',
        n_coils=image.shape[0],
        density_comp=density_comp,
        smaps=Smaps,
    )
    # This preconditions k-space giving a result closer to inverse
    image_rec = fourier_op_sense_dc.adj_op(kspace_obs)
    recon_ssim = ssim(image_rec, cartesian, mask=np.abs(image)>np.mean(np.abs(image)))
    plt.imshow(np.abs(image_rec)[..., 80], cmap='gray')
    plt.title('Density Compensated Adjoint : SSIM = ' + str(np.around(recon_ssim, 2)))
    plt.show()



.. GENERATED FROM PYTHON SOURCE LINES 109-114

FISTA optimization
------------------

We now want to refine the zero order solution using a FISTA optimization.
The cost function is set to Proximity Cost + Gradient Cost

.. GENERATED FROM PYTHON SOURCE LINES 114-130

.. code-block:: default


    # Setup the operators
    linear_op = WaveletN(
        wavelet_name='sym8',
        nb_scale=4,
        dim=3,
    )
    regularizer_op = SparseThreshold(Identity(), 1e-11, thresh_type="soft")
    # Setup Reconstructor
    reconstructor = SelfCalibrationReconstructor(
        fourier_op=fourier_op_sense_dc,
        linear_op=linear_op,
        regularizer_op=regularizer_op,
        gradient_formulation='synthesis',
        verbose=1,
    )

.. GENERATED FROM PYTHON SOURCE LINES 131-132

Run the FISTA reconstruction and view results

.. GENERATED FROM PYTHON SOURCE LINES 132-141

.. code-block:: default

    image_rec, costs, metrics = reconstructor.reconstruct(
        kspace_data=kspace_obs,
        optimization_alg='fista',
        num_iterations=30,
    )
    recon_ssim = ssim(image_rec, cartesian)
    plt.imshow(np.abs(image_rec)[..., 80], cmap='gray')
    plt.title('Iterative Reconstruction : SSIM = ' + str(np.around(recon_ssim, 2)))
    plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)


.. _sphx_glr_download_auto_examples_pysap-mri_GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/cea-cosmic/pysap/gh-pages?urlpath=lab/tree/notebooks/auto_examples/pysap-mri/GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.py <GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.ipynb <GPU_NonCartesian_gpuNUFFT_SENSE_DensityCompensation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
